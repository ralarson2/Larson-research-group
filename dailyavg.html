<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PM2.5 average concentrations by day of the week – Larson Research Group</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 1rem; background:#f7f9fb; color:#222;}
    h1 { font-size:1.6rem; margin-bottom:0.5rem; }
    p { max-width: 960px; color:#4b5c67; margin-bottom: 0.9rem; }
    label { font-weight:500; margin-right:0.5rem; }
    select { padding:0.35rem 0.5rem; font-size:0.95rem; margin-bottom:1rem; }
    .wrap { max-width: 960px; }
    .card { background:#fff; border:1px solid #dde3ea; border-radius:0.9rem; padding:1rem 1.1rem; box-shadow: 0 8px 20px rgba(15,35,52,0.04); }
    .chart-container { height: 420px; width:100%; margin-top: 0.75rem; }
    table { border-collapse: collapse; width:100%; margin-top:0.9rem; font-size: 0.95rem; }
    th, td { border:1px solid #dde3ea; padding:0.55rem; text-align:left; }
    th { background:#eef3f7; }
    td:last-child { text-align:right; }
    .status { margin-top:0.5rem; color:#4b5c67; font-size:0.95rem; }
    a { color:#1b7c6d; text-decoration:none; }
    a:hover { text-decoration:underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PM2.5 average concentrations by day of the week</h1>
    <p>This page uses the archived AirQo dataset on this site and plots calibrated PM2.5 (pm2_5_calibrated_value). Missing values are left blank. All day-of-week calculations use Uganda local time (Africa/Kampala).</p>

    <div class="card">
      <div>
        <label for="sensor-select">Sensor</label>
        <select id="sensor-select"></select>
      </div>

      <div class="status" id="status">Loading archive…</div>

      <div class="chart-container">
        <canvas id="pm25-daily-chart"></canvas>
      </div>

      <table id="pm25-daily-table" aria-label="Daily averages table">
        <thead>
          <tr>
            <th>Day of the week</th>
            <th>Average PM2.5 (µg/m³)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <div class="status" style="margin-top:0.9rem;">
        <a href="uganda.html">Back to Uganda air quality page</a>
      </div>
    </div>
  </div>

<script>
  const CSV_URL = "data/uganda_pm25_archive.csv";
  const DAYS = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
  const UGANDA_TZ = "Africa/Kampala";

  function normalizeIso(dt) {
    // Make parsing tolerant of "YYYY-MM-DD HH:MM:SSZ" and "YYYY-MM-DD HH:MM:SS"
    // AirQo API timestamps are documented as UTC; if no timezone marker exists, assume UTC.
    // If your CSV truly contains already-local times without timezone info, remove the 'Z' append below.
    let s = String(dt || "").trim();
    if (!s) return "";

    // Replace space between date/time with 'T' for ISO compatibility
    if (s.includes(" ") && !s.includes("T")) s = s.replace(" ", "T");

    // If it ends with 'Z' or contains an offset, keep it
    const hasTz = /Z$/.test(s) || /[+\-]\d{2}:\d{2}$/.test(s) || /[+\-]\d{4}$/.test(s);
    if (!hasTz) s = s + "Z";

    return s;
  }

  function parseTimeMs(isoLike) {
    const s = normalizeIso(isoLike);
    const ms = Date.parse(s);
    return Number.isFinite(ms) ? ms : null;
  }

  function dayOfWeekUganda(ms) {
    return new Date(ms).toLocaleDateString("en-US", { weekday: "long", timeZone: UGANDA_TZ });
  }

  function fmtNumber(v) {
    const n = Number(v);
    return Number.isFinite(n) ? n.toFixed(1) : "";
  }

  function parseCsv(text) {
    const rows = [];
    let row = [];
    let field = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      const next = text[i + 1];

      if (inQuotes) {
        if (c === '"' && next === '"') { field += '"'; i++; continue; }
        if (c === '"') { inQuotes = false; continue; }
        field += c;
        continue;
      }

      if (c === '"') { inQuotes = true; continue; }
      if (c === ",") { row.push(field); field = ""; continue; }
      if (c === "\n") {
        row.push(field);
        if (row.length > 1 || row[0].trim() !== "") rows.push(row);
        row = [];
        field = "";
        continue;
      }
      if (c === "\r") continue;

      field += c;
    }

    if (field.length || row.length) {
      row.push(field);
      if (row.length > 1 || row[0].trim() !== "") rows.push(row);
    }

    return rows;
  }

  let chart = null;
  let bySensor = {};              // device_name -> [{ datetime, pm25 }]
  let sensorLabelByDevice = {};   // device_name -> site_name (fallback device_name)

  function buildDropdown(items) {
    const sel = document.getElementById("sensor-select");
    sel.innerHTML = "";

    items.forEach(it => {
      const opt = document.createElement("option");
      opt.value = it.device;
      opt.textContent = it.label;
      sel.appendChild(opt);
    });

    sel.addEventListener("change", e => render(e.target.value));
  }

  function render(sensorDeviceName) {
    const status = document.getElementById("status");
    const rows = bySensor[sensorDeviceName] || [];

    const buckets = {};
    DAYS.forEach(d => buckets[d] = []);

    rows.forEach(r => {
      const ms = parseTimeMs(r.datetime);
      if (ms === null) return;
      if (!Number.isFinite(r.pm25)) return;

      const d = dayOfWeekUganda(ms);
      if (buckets[d]) buckets[d].push(r.pm25);
    });

    const avgByDay = DAYS.map(d => {
      const arr = buckets[d];
      if (!arr.length) return { day: d, avg: null };
      const sum = arr.reduce((a,b) => a + b, 0);
      return { day: d, avg: sum / arr.length };
    });

    const label = sensorLabelByDevice[sensorDeviceName] || sensorDeviceName;
    status.textContent = `Loaded ${rows.length.toLocaleString()} records for ${label}. Times grouped in Uganda local time.`;

    const ctx = document.getElementById("pm25-daily-chart").getContext("2d");
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: "bar",
      data: {
        labels: avgByDay.map(x => x.day),
        datasets: [{
          label: "PM2.5 (µg/m³)",
          data: avgByDay.map(x => x.avg)
        }]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false } },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: "PM2.5 (µg/m³)" } }
        }
      }
    });

    const tbody = document.querySelector("#pm25-daily-table tbody");
    tbody.innerHTML = "";
    avgByDay.forEach(d => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${d.day}</td><td>${d.avg === null ? "" : fmtNumber(d.avg)}</td>`;
      tbody.appendChild(tr);
    });
  }

  async function loadArchive() {
    const status = document.getElementById("status");
    try {
      const res = await fetch(CSV_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`Archive CSV not found: ${CSV_URL} (HTTP ${res.status})`);

      const text = await res.text();
      const rows = parseCsv(text);
      if (rows.length < 2) throw new Error("Archive CSV is empty");

      const header = rows[0].map(h => h.trim());

      const idxDatetime = header.indexOf("datetime");
      const idxDeviceName = header.indexOf("device_name");
      const idxSiteName = header.indexOf("site_name");
      const idxPm25Cal = header.indexOf("pm2_5_calibrated_value");

      if (idxDatetime < 0 || idxDeviceName < 0 || idxPm25Cal < 0) {
        throw new Error("CSV header missing required columns: datetime, device_name, pm2_5_calibrated_value");
      }

      bySensor = {};
      sensorLabelByDevice = {};

      for (let i = 1; i < rows.length; i++) {
        const cols = rows[i];
        const datetime = cols[idxDatetime];
        const device = cols[idxDeviceName];
        const site = (idxSiteName >= 0 ? cols[idxSiteName] : "") || "";
        const pm25 = Number(cols[idxPm25Cal]);

        if (!datetime || !device) continue;
        if (!Number.isFinite(pm25)) continue;

        const label = (site && site.trim()) ? site.trim() : device;
        if (!sensorLabelByDevice[device]) sensorLabelByDevice[device] = label;

        if (!bySensor[device]) bySensor[device] = [];
        bySensor[device].push({ datetime, pm25 });
      }

      const devices = Object.keys(bySensor).sort((a,b) => {
        const la = (sensorLabelByDevice[a] || a).toLowerCase();
        const lb = (sensorLabelByDevice[b] || b).toLowerCase();
        return la.localeCompare(lb);
      });

      if (!devices.length) {
        status.textContent = "No usable calibrated PM2.5 data found in the archive.";
        return;
      }

      devices.forEach(d => {
        bySensor[d].sort((a,b) => (parseTimeMs(a.datetime) ?? 0) - (parseTimeMs(b.datetime) ?? 0));
      });

      const items = devices.map(d => ({ device: d, label: sensorLabelByDevice[d] || d }));

      buildDropdown(items);
      render(devices[0]);
    } catch (e) {
      console.error(e);
      status.textContent = "Could not load the archive data for this page.";
    }
  }

  loadArchive();
</script>
</body>
</html>
